#define AA 2  //change to 1 to increase performance

#define _Speed 3.0  //disk rotation speed

#define _Steps  12. //disk texture layers
#define _Size 0.3 //size of BH



float hash(float x)
{
    return frac(sin(x) * 152754.742);
}
float hash(float2 x)
{
    return hash(x.x + hash(x.y));
}

float value(float2 p, float f) //value noise
{
    float bl = hash(floor(p * f + float2(0., 0.)));
    float br = hash(floor(p * f + float2(1., 0.)));
    float tl = hash(floor(p * f + float2(0., 1.)));
    float tr = hash(floor(p * f + float2(1., 1.)));
    
    float2 fr = frac(p * f);
    fr = (3. - 2. * fr) * fr * fr;
    float b = lerp(bl, br, fr.x);
    float t = lerp(tl, tr, fr.x);
    return lerp(b, t, fr.y);
}

float4 background(Texture2D tex, float3 ray)
{
    float2 uv = ray.xy;
    
    if (abs(ray.x) > 0.5)
        uv.x = ray.z;
    else if (abs(ray.y) > 0.5)
        uv.y = ray.z;

        
    float brightness = value(uv * 3., 100.); //(poor quality) "stars" created from value noise
    float color = value(uv * 2., 20.);
    brightness = pow(brightness, 256.);
  
    brightness = brightness * 100.;
    brightness = clamp(brightness, 0., 1.);
    
    float3 stars = brightness * lerp(float3(1., .6, .2), float3(.2, .6, 1), color);

    //float4 nebulae = texture(tex, (uv * 1.5));
    SamplerState texSampler;
    float4 nebulae = Texture2DSample(tex, texSampler, (uv * 1.5));
    nebulae.xyz += nebulae.xxx + nebulae.yyy + nebulae.zzz; //average color
    nebulae.xyz *= 0.25;
    
    nebulae *= nebulae;
    nebulae *= nebulae;
    nebulae *= nebulae;
    nebulae *= nebulae;
 
    nebulae.xyz += stars;
    return nebulae;
}

float4 raymarchDisk(float iTime, float3 ray, float3 zeroPos)
{
    //return float4(1.,1.,1.,0.); //no disk
    
    float3 position = zeroPos;
    float lengthPos = length(position.xz);
    float dist = min(1., lengthPos * (1. / _Size) * 0.5) * _Size * 0.4 * (1. / _Steps) / (abs(ray.y));

    position += dist * _Steps * ray * 0.5;

    float2 deltaPos;
    deltaPos.x = -zeroPos.z * 0.01 + zeroPos.x;
    deltaPos.y = zeroPos.x * 0.01 + zeroPos.z;
    deltaPos = normalize(deltaPos - zeroPos.xz);
    
    float parallel = dot(ray.xz, deltaPos);
    parallel /= sqrt(lengthPos);
    parallel *= 0.5;
    float redShift = parallel + 0.3;
    redShift *= redShift;

    redShift = clamp(redShift, 0., 1.);
    
    float disMix = clamp((lengthPos - _Size * 2.) * (1. / _Size) * 0.24, 0., 1.);
    float3 insideCol = lerp(float3(1.0, 0.8, 0.0), float3(0.5, 0.13, 0.02) * 0.2, disMix);
    
    insideCol *= lerp(float3(0.4, 0.2, 0.1), float3(1.6, 2.4, 4.0), redShift);
    insideCol *= 1.25;
    redShift += 0.12;
    redShift *= redShift;

    float4 o = float4(0.f, 0.f, 0.f, 0.f);

    for (float i = 0.; i < _Steps; i++)
    {
        position -= dist * ray;

        float intensity = clamp(1. - abs((i - 0.8) * (1. / _Steps) * 2.), 0., 1.);
        float lengthPos = length(position.xz);
        float distMult = 1.;

        distMult *= clamp((lengthPos - _Size * 0.75) * (1. / _Size) * 1.5, 0., 1.);
        distMult *= clamp((_Size * 10. - lengthPos) * (1. / _Size) * 0.20, 0., 1.);
        distMult *= distMult;

        float u = lengthPos + iTime * _Size * 0.3 + intensity * _Size * 0.2;

        float2 xy;
        float rot = fmod(iTime * _Speed, 8192.);
        xy.x = -position.z * sin(rot) + position.x * cos(rot);
        xy.y = position.x * sin(rot) + position.z * cos(rot);

        float x = abs(xy.x / (xy.y));
        float angle = 0.02 * atan(x);
  
        const float f = 70.;
        float noise = value(float2(angle, u * (1. / _Size) * 0.05), f);
        noise = noise * 0.66 + 0.33 * value(float2(angle, u * (1. / _Size) * 0.05), f * 2.);

        float extraWidth = noise * 1. * (1. - clamp(i * (1. / _Steps) * 2. - 1., 0., 1.));

        float alpha = clamp(noise * (intensity + extraWidth) * ((1. / _Size) * 10. + 0.01) * dist * distMult, 0., 1.);

        float3 col = 2. * lerp(float3(0.3, 0.2, 0.15) * insideCol, insideCol, min(1., intensity * 2.));
        o = clamp(float4(col * alpha + o.rgb * (1. - alpha), o.a * (1. - alpha) + alpha), float4(0.f, 0.f, 0.f, 0.f), float4(1.f, 1.f, 1.f, 1.f));

        lengthPos *= (1. / _Size);
   
        o.rgb += redShift * (intensity * 1. + 0.5) * (1. / _Steps) * 100. * distMult / (lengthPos * lengthPos);
    }
 
    o.rgb = clamp(o.rgb - 0.005, 0., 1.);
    return o;
}


void Rotate(inout float3 Vector, float2 angle)
{
    Vector.yz = cos(angle.y) * Vector.yz +sin(angle.y) * float2(-1, 1) * Vector.zy;
    Vector.xz = cos(angle.x) * Vector.xz +sin(angle.x) * float2(-1, 1) * Vector.zx;
}

float4 ShowBlackHole(float iTime, float2 fragCoord, float2 iResolution, Texture2D tex/*, float3 cameraPos*/)
{
    float4 colOut = float4(0.f, 0.f, 0.f, 0.f);
    
    float2 fragCoordRot;
    fragCoordRot.x = fragCoord.x * 0.985 + fragCoord.y * 0.174;
    fragCoordRot.y = fragCoord.y * 0.985 - fragCoord.x * 0.174;
    fragCoordRot += float2(-0.06, 0.12) * iResolution.xy;
    
    for (int j = 0; j < AA; j++)
        for (int i = 0; i < AA; i++)
        {
        //setting up camera
            float3 ray = normalize(float3((fragCoordRot - iResolution.xy * .5 + float2(i, j) / (float(AA))) / iResolution.x, 1));
            float3 pos = float3(0., 0.05, -((iResolution.x * 0.5) / iResolution.x - 10.) * ((iResolution.y * 0.5) / iResolution.y - 10.) * .05);
            //float3 pos = float3(0., 0.05, -(20. * cameraPos.x / iResolution.x - 10.) * (20. * cameraPos.y / iResolution.y - 10.) * .05);
            float2 angle = float2(iTime * 0.1, .2);
            angle.y = (2. * iResolution.y / iResolution.y) * 3.14 + 0.1 + 3.14;
            float dist = length(pos);
            Rotate(pos, angle);
            angle.xy -= min(.3 / dist, 3.14) * float2(1, 0.5);
            Rotate(ray, angle);

            float4 col = float4(0.f, 0.f, 0.f, 0.f);
            float4 glow = float4(0.f, 0.f, 0.f, 0.f);
            float4 outCol = float4(100.f, 100.f, 100.f, 100.f);

            for (int disks = 0; disks < 20; disks++) //steps
            {

                for (int h = 0; h < 6; h++) //reduces tests for exit conditions (to minimise branching)
                {
                    float dotpos = dot(pos, pos);
                    float invDist = 1 / sqrt(dotpos); //1/distance to BH
                    //float invDist = inversesqrt(dotpos); //1/distance to BH
                    float centDist = dotpos * invDist; //distance to BH
                    float stepDist = 0.92 * abs(pos.y / (ray.y)); //conservative distance to disk (y==0)   
                    float farLimit = centDist * 0.5; //limit step size far from to BH
                    float closeLimit = centDist * 0.1 + 0.05 * centDist * centDist * (1. / _Size); //limit step size closse to BH
                    stepDist = min(stepDist, min(farLimit, closeLimit));
				
                    float invDistSqr = invDist * invDist;
                    float bendForce = stepDist * invDistSqr * _Size * 0.625; //bending force
                    ray = normalize(ray - (bendForce * invDist) * pos); //bend ray towards BH
                    pos += stepDist * ray;
                
                    glow += float4(1.2, 1.1, 1, 1.0) * (0.01 * stepDist * invDistSqr * invDistSqr * clamp(centDist * (2.) - 1.2, 0., 1.)); //adds fairly cheap glow
                }

                float dist2 = length(pos);

                if (dist2 < _Size * 0.1) //光亮进入黑洞区域
                {
                    outCol = float4(col.rgb * col.a + glow.rgb * (1. - col.a), 1.);
                    break;
                }
                else if (dist2 > _Size * 1000.) //光亮跳出黑洞区域
                {
                    float4 bg = background(tex, ray);
                    outCol = float4(col.rgb * col.a + bg.rgb * (1. - col.a) + glow.rgb * (1. - col.a), 1.);
                    break;
                }
                else if (abs(pos.y) <= _Size * 0.002) //亮度吸积盘
                {
                    float4 diskCol = raymarchDisk(iTime, ray, pos); //吸积盘
                    pos.y = 0.;
                    pos += abs(_Size * 0.001 / ray.y) * ray;
                    col = float4(diskCol.rgb * (1. - col.a) + col.rgb, col.a + diskCol.a * (1. - col.a));
                }
            }
   
        //if the ray never escaped or got sucked in
            if (outCol.r == 100.)
                outCol = float4(col.rgb + glow.rgb * (col.a + glow.a), 1.);

            col = outCol;
            col.rgb = pow(col.rgb, float3(0.6, 0.6, 0.6));
        
            colOut += col / float(AA * AA);
        }
    return colOut;
}

float4 ShowBlackHole2(float iTime, float2 fragCoord, float2 iResolution, Texture2D tex)
{
    float4 colOut = float4(0.f, 0.f, 0.f, 0.f);
    
    float2 fragCoordRot;
    fragCoordRot.x = fragCoord.x * 0.985 + fragCoord.y * 0.174;
    fragCoordRot.y = fragCoord.y * 0.985 - fragCoord.x * 0.174;
    fragCoordRot += float2(-0.06, 0.12) * iResolution.xy;
    
    float3 ray = normalize(float3((fragCoordRot - iResolution.xy * .5) / iResolution.x, 1));
    float3 pos = float3(0., 0.05, -((iResolution.x * 0.5) / iResolution.x - 10.) * ((iResolution.y * 0.5) / iResolution.y - 10.) * .05);
    
    float4 col = float4(0.f, 0.f, 0.f, 0.f);
    float4 glow = float4(0.f, 0.f, 0.f, 0.f);
    float4 outCol = float4(100.f, 100.f, 100.f, 100.f);

    for (int disks = 0; disks < 20; disks++) //steps
    {

        for (int h = 0; h < 6; h++) //reduces tests for exit conditions (to minimise branching)
        {
            float dotpos = dot(pos, pos);
            float invDist = 1 / sqrt(dotpos); //1/distance to BH
            //float invDist = inversesqrt(dotpos); //1/distance to BH
            float centDist = dotpos * invDist; //distance to BH
            float stepDist = 0.92 * abs(pos.y / (ray.y)); //conservative distance to disk (y==0)   
            float farLimit = centDist * 0.5; //limit step size far from to BH
            float closeLimit = centDist * 0.1 + 0.05 * centDist * centDist * (1. / _Size); //limit step size closse to BH
            stepDist = min(stepDist, min(farLimit, closeLimit));
				
            float invDistSqr = invDist * invDist;
            float bendForce = stepDist * invDistSqr * _Size * 0.625; //bending force
            ray = normalize(ray - (bendForce * invDist) * pos); //bend ray towards BH
            pos += stepDist * ray;
                
            glow += float4(1.2, 1.1, 1, 1.0) * (0.01 * stepDist * invDistSqr * invDistSqr * clamp(centDist * (2.) - 1.2, 0., 1.)); //adds fairly cheap glow
        }

        float dist2 = length(pos);

        if (dist2 < _Size * 0.1) //ray sucked in to BH
        {
            outCol = float4(col.rgb * col.a + glow.rgb * (1. - col.a), 1.);
            break;
        }
        else if (dist2 > _Size * 1000.) //ray escaped BH
        {
            float4 bg = background(tex, ray);
            outCol = float4(col.rgb * col.a + bg.rgb * (1. - col.a) + glow.rgb * (1. - col.a), 1.);
            break;
        }
        else if (abs(pos.y) <= _Size * 0.002) //ray hit accretion disk
        {
            float4 diskCol = raymarchDisk(iTime, ray, pos); //render disk
            pos.y = 0.;
            pos += abs(_Size * 0.001 / ray.y) * ray;
            col = float4(diskCol.rgb * (1. - col.a) + col.rgb, col.a + diskCol.a * (1. - col.a));
        }
    }
   
    //if the ray never escaped or got sucked in
    if (outCol.r == 100.)
        outCol = float4(col.rgb + glow.rgb * (col.a + glow.a), 1.);

    col = outCol;
    col.rgb = pow(col.rgb, float3(0.6, 0.6, 0.6));
    colOut = col;
    return colOut;
}
